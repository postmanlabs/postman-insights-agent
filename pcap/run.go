package pcap

import (
	"os"
	"time"

	"github.com/akitasoftware/akita-libs/akid"
	"github.com/akitasoftware/akita-libs/akinet"
	akihttp "github.com/akitasoftware/akita-libs/akinet/http"
	akihttp2 "github.com/akitasoftware/akita-libs/akinet/http2"
	"github.com/akitasoftware/akita-libs/akinet/tls"
	"github.com/akitasoftware/akita-libs/buffer_pool"
	. "github.com/akitasoftware/akita-libs/client_telemetry"
	"github.com/akitasoftware/akita-libs/tags"
	"github.com/akitasoftware/go-utils/optionals"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/pkg/errors"
	"github.com/postmanlabs/postman-insights-agent/printer"
	"github.com/postmanlabs/postman-insights-agent/telemetry"
	"github.com/postmanlabs/postman-insights-agent/trace"
)

func Collect(
	serviceID akid.ServiceID,
	traceTags map[tags.Key]string,
	stop <-chan struct{},
	intf string,
	bpfFilter string,
	targetNetworkNamespaceOpt optionals.Optional[string],
	bufferShare float32,
	parseTCPAndTLS bool,
	proc trace.Collector,
	packetCount trace.PacketCountConsumer,
	pool buffer_pool.BufferPool,
	telemetry telemetry.Tracker,
) error {
	defer proc.Close()

	facts := []akinet.TCPParserFactory{
		akihttp.NewHTTPRequestParserFactory(pool),
		akihttp.NewHTTPResponseParserFactory(pool),
		akihttp2.NewHTTP2PrefaceParserFactory(),
	}
	if parseTCPAndTLS {
		facts = append(facts,
			tls.NewTLSClientParserFactory(),
			tls.NewTLSServerParserFactory(),
		)
	}

	// Check if HTTPS capture file exists (from ecapture sidecar)
	if tlsCapturePath := detectTLSCaptureFile(); tlsCapturePath != "" {
		printer.Infof("HTTPS capture enabled via file: %s\n", tlsCapturePath)
		// Start file-based collection in background
		go collectFromFile(tlsCapturePath, serviceID, traceTags, stop, facts, proc, packetCount, pool, telemetry)
	} else {
		printer.Debugf("No HTTPS capture file detected, continuing with HTTP-only capture\n")
	}

	parser := NewNetworkTrafficParser(serviceID, traceTags, bufferShare, telemetry)

	if packetCount != nil {
		parser.InstallObserver(CountTcpPackets(intf, packetCount))
	}

	parsedChan, err := parser.ParseFromInterface(intf, bpfFilter, targetNetworkNamespaceOpt, stop, facts...)
	if err != nil {
		return errors.Wrap(err, "couldn't start parsing from interface")
	}

	startTime := time.Now()
	bufferTimeSum := 0 * time.Second
	intervalLength := 1 * time.Minute
	for t := range parsedChan {
		now := time.Now()
		if now.Sub(startTime) >= intervalLength {
			bufferLength := float64(bufferTimeSum.Nanoseconds()) / float64(intervalLength.Nanoseconds())
			podName, ok := traceTags[tags.XAkitaKubernetesPod]
			if !ok {
				podName = "unknown"
			}
			printer.Debugf("Approximate parsed-network-traffic buffer length: %v, for svc: %v and pod: %v\n", bufferLength, serviceID, podName)
			bufferTimeSum = 0 * time.Second
			startTime = now
		}
		bufferTimeSum += now.Sub(t.ObservationTime)

		t.Interface = intf
		err := proc.Process(t)
		t.Content.ReleaseBuffers()
		if err != nil {
			return err
		}
	}

	return nil
}

// Observe every captured TCP segment here
func CountTcpPackets(ifc string, packetCount trace.PacketCountConsumer) NetworkTrafficObserver {
	observer := func(p gopacket.Packet) {
		if tcpLayer := p.Layer(layers.LayerTypeTCP); tcpLayer != nil {
			tcp, _ := tcpLayer.(*layers.TCP)
			packetCount.Update(PacketCounts{
				Interface:  ifc,
				SrcPort:    int(tcp.SrcPort),
				DstPort:    int(tcp.DstPort),
				TCPPackets: 1,
			})
		}
	}
	return NetworkTrafficObserver(observer)
}

// detectTLSCaptureFile checks if an HTTPS capture file exists (from ecapture sidecar).
// Returns the file path if found, empty string otherwise.
func detectTLSCaptureFile() string {
	// Check common paths where ecapture might write output
	candidatePaths := []string{
		os.Getenv("TLS_CAPTURE_PATH"), // Allow override via env var
		"/tmp/shared/tls.txt",
		"/tmp/shared/tls.pcap",
	}

	for _, path := range candidatePaths {
		if path == "" {
			continue
		}
		if _, err := os.Stat(path); err == nil {
			return path
		}
	}

	return ""
}

// collectFromFile reads packets from a pcap file (e.g., generated by ecapture)
// and processes them through the same pipeline as live capture.
// This runs in a separate goroutine and feeds into the same processor as live capture.
func collectFromFile(
	filePath string,
	serviceID akid.ServiceID,
	traceTags map[tags.Key]string,
	stop <-chan struct{},
	facts []akinet.TCPParserFactory,
	proc trace.Collector,
	packetCount trace.PacketCountConsumer,
	pool buffer_pool.BufferPool,
	telemetry telemetry.Tracker,
) {
	const tag = "https-capture"

	// Create a parser with file-based pcap wrapper
	parser := NewNetworkTrafficParser(serviceID, traceTags, 1.0, telemetry)
	parser.pcap = fileCaptureReader(filePath)

	// Install packet counting observer if provided (same as live capture)
	if packetCount != nil {
		parser.InstallObserver(CountTcpPackets(tag, packetCount))
	}

	parsedChan, err := parser.ParseFromInterface(tag, "", optionals.None[string](), stop, facts...)
	if err != nil {
		printer.Errorf("Failed to start parsing from HTTPS capture file %s: %v\n", filePath, err)
		return
	}

	printer.Debugf("Started collecting HTTPS traffic from file: %s\n", filePath)

	for t := range parsedChan {
		// Tag traffic as coming from HTTPS capture
		t.Interface = "https-capture"

		err := proc.Process(t)
		t.Content.ReleaseBuffers()
		if err != nil {
			printer.Errorf("Error processing HTTPS traffic from file: %v\n", err)
			return
		}
	}

	printer.Debugf("Finished collecting HTTPS traffic from file: %s\n", filePath)
}
