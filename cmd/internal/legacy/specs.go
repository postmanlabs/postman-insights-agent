package legacy

import (
	"context"
	"io"
	"os"
	"time"

	"github.com/akitasoftware/akita-libs/akid"
	kgxapi "github.com/akitasoftware/akita-libs/api_schema"
	"github.com/jpillora/backoff"
	"github.com/pkg/errors"
	"github.com/postmanlabs/postman-insights-agent/cmd/internal/cmderr"
	"github.com/postmanlabs/postman-insights-agent/rest"
	"github.com/spf13/cobra"
)

var SpecsCmd = &cobra.Command{
	Use:          "specs",
	Short:        "Manage API specs",
	Long:         "Manage API specifications generated by Akita.",
	SilenceUsage: true,
	Args:         cobra.ExactArgs(0),
	RunE: func(cmd *cobra.Command, _ []string) error {
		return cmd.Help()
	},
}

var getSpecCmd = &cobra.Command{
	Use:   "get [ID|VERSION]",
	Short: "Get an API Spec",
	Long: `Get an API specification from Akita cloud.

You may specify the API spec by version name (e.g. "latest") or an ID (e.g.
"api_6EHHvqIrMzXvfKlBqBHFoX").
`,
	SilenceUsage: true,
	Args:         cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		// args[0] is guaranteed to work due to ExactArgs(1)
		if err := runGetSpec(args[0]); err != nil {
			return cmderr.AkitaErr{Err: err}
		}
		return nil
	},
}

// GetSpec flags
var (
	getSpecProjectIDFlag           string
	getSpecOutputFlag              string
	getSpecTimeoutFlag             time.Duration
	getSpecWaitFlag                bool
	getSpecEnableRelatedFieldsFlag bool
)

func init() {
	SpecsCmd.AddCommand(getSpecCmd)

	getSpecCmd.Flags().StringVar(
		&getSpecProjectIDFlag,
		"project",
		"",
		"Your Insights project ID.",
	)
	cobra.MarkFlagRequired(getSpecCmd.Flags(), "service")

	getSpecCmd.Flags().StringVar(
		&getSpecOutputFlag,
		"output",
		"",
		"Where to write the API spec. Defaults to stdout.",
	)

	getSpecCmd.Flags().DurationVar(
		&getSpecTimeoutFlag,
		"timeout",
		10*time.Second,
		"Timeout for fetching the spec.",
	)

	getSpecCmd.Flags().BoolVar(
		&getSpecWaitFlag,
		"wait",
		false,
		`If set, waits for the spec to be fully computed before exiting.

The default behavior exits immediately with an error if the spec is pending.

When set, the CLI attempts to fetch the API spec multiple times until Akita is
done computing it. This flag may be used in conjunction with --timeout to
control the timeout for each fetch attempt.`,
	)

	// Filtering flags.
	getSpecCmd.Flags().BoolVar(
		&getSpecEnableRelatedFieldsFlag,
		"infer-field-relations",
		false,
		"If true, enables analysis to determine related fields in your API.",
	)
}

func runGetSpec(specIdentifier string) error {
	// Make sure we have a valid output target.
	var out io.WriteCloser
	if getSpecOutputFlag == "" {
		out = os.Stdout
	} else {
		if f, err := os.OpenFile(getSpecOutputFlag, os.O_WRONLY|os.O_CREATE, 0644); err != nil {
			return errors.Wrapf(err, "failed to open output file %s", getSpecOutputFlag)
		} else {
			out = f
		}
	}
	defer out.Close()

	clientID := akid.GenerateClientID()

	var serviceID akid.ServiceID
	err := akid.ParseIDAs(getSpecProjectIDFlag, &serviceID)
	if err != nil {
		return errors.Wrap(err, "failed to parse project ID")
	}
	learnClient := rest.NewLearnClient(rest.Domain, clientID, serviceID, nil, nil)

	// Check to see if the user specified an AkID or a version name.
	var specID akid.APISpecID
	if err := akid.ParseIDAs(specIdentifier, &specID); err != nil {
		// Try resolving the version name.
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		if version, err := learnClient.GetSpecVersion(ctx, specIdentifier); err != nil {
			return errors.Wrapf(err, "failed to get spec version %s", specIdentifier)
		} else {
			specID = version.APISpecID
		}
		cancel()
	}

	// Fetch the spec, optionally waiting for pending specs to become DONE.
	var spec kgxapi.GetSpecResponse
	getSpecBackoff := &backoff.Backoff{
		Min:    5 * time.Second,
		Max:    5 * time.Minute,
		Factor: 1.2,
		Jitter: true,
	}
	opts := rest.GetSpecOptions{
		EnableRelatedTypes: getSpecEnableRelatedFieldsFlag,
	}
	for {
		var err error
		ctx, cancel := context.WithTimeout(context.Background(), getSpecTimeoutFlag)
		spec, err = learnClient.GetSpec(ctx, specID, opts)
		cancel()
		if err != nil {
			return errors.Wrap(err, "failed to get spec, maybe try increasing --timeout")
		}

		if spec.State != kgxapi.APISpecDone {
			if !getSpecWaitFlag {
				return errors.New("API spec is still being created, please try again soon")
			}
			// Backoff and wait for the spec to become ready.
			time.Sleep(getSpecBackoff.Duration())
		} else {
			break
		}
	}

	// Output
	{
		s := spec.Content
		for len(s) > 0 {
			if n, err := io.WriteString(out, s); err != nil {
				return errors.Wrap(err, "failed to write output")
			} else {
				s = s[n:]
			}
		}
	}

	return nil
}
